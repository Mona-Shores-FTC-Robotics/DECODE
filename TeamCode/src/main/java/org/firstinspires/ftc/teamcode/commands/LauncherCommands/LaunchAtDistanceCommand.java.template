package org.firstinspires.ftc.teamcode.commands.LauncherCommands;

import com.bylazar.configurables.annotations.Configurable;
import com.qualcomm.robotcore.util.Range;

import dev.nextftc.core.commands.Command;

import org.firstinspires.ftc.teamcode.subsystems.LauncherSubsystem;
import org.firstinspires.ftc.teamcode.subsystems.VisionSubsystemLimelight;
import org.firstinspires.ftc.teamcode.util.LauncherLane;

import java.util.Objects;
import java.util.Optional;

/**
 * PHASE 3 TEMPLATE - Distance-based launcher RPM calculation
 *
 * To use this:
 * 1. Rename file to LaunchAtDistanceCommand.java (remove .template)
 * 2. Fill in FormulaConfig values from your data analysis
 * 3. Update Robot.java or autonomous commands to use this instead of LaunchAtPositionCommand
 * 4. Test thoroughly before competition
 *
 * This command:
 * - Calculates optimal RPM from distance to goal
 * - Uses AprilTag vision for distance if available
 * - Falls back to estimated distance from robot pose
 * - Has configurable formula coefficients (tune in Dashboard)
 */
@Configurable
public class LaunchAtDistanceCommand extends Command {

    @Configurable
    public static class FormulaConfig {
        /**
         * Linear formula: RPM = (slope * distance) + intercept
         * Fit these from your practice data (see LAUNCHER_RPM_ROADMAP.md)
         */

        /** RPM increase per inch of distance (fit from data) */
        public static double rpmSlope = 25.0; // TODO: Replace with fitted value

        /** Base RPM at 0 distance (fit from data) */
        public static double rpmIntercept = 1500.0; // TODO: Replace with fitted value

        /**
         * Alternative: Quadratic formula (if data shows non-linear relationship)
         * RPM = (a * distance²) + (b * distance) + c
         * Set useQuadratic = true to enable
         */
        public static boolean useQuadratic = false;
        public static double quadraticA = 0.0; // TODO: Fit from data
        public static double quadraticB = 0.0; // TODO: Fit from data
        public static double quadraticC = 0.0; // TODO: Fit from data

        /** Safety limits */
        public static double minRpm = 2000.0;
        public static double maxRpm = 5000.0;

        /** Timeout waiting for spinup */
        public static double timeoutSeconds = 3.0;

        /** Use vision for distance (false = use pose estimate) */
        public static boolean useVisionDistance = true;
    }

    private final LauncherSubsystem launcher;
    private final VisionSubsystemLimelight vision; // null if vision not available
    private final double fallbackDistanceInches;
    private double targetRpm = 0.0;
    private double startTime = 0.0;

    /**
     * Creates command with vision-based distance
     */
    public LaunchAtDistanceCommand(LauncherSubsystem launcher, VisionSubsystemLimelight vision) {
        this.launcher = Objects.requireNonNull(launcher, "launcher required");
        this.vision = vision;
        this.fallbackDistanceInches = 72.0; // Default ~6 feet
        requires(launcher);
        setInterruptible(true);
    }

    /**
     * Creates command with known distance (no vision)
     */
    public LaunchAtDistanceCommand(LauncherSubsystem launcher, double distanceInches) {
        this.launcher = Objects.requireNonNull(launcher, "launcher required");
        this.vision = null;
        this.fallbackDistanceInches = distanceInches;
        requires(launcher);
        setInterruptible(true);
    }

    @Override
    public void start() {
        // Get distance to goal
        double distanceInches = getDistanceToGoal();

        // Calculate optimal RPM
        targetRpm = calculateRpmForDistance(distanceInches);

        // Set RPM for enabled launchers
        launcher.setLaunchRpm(LauncherLane.LEFT, targetRpm);
        launcher.setLaunchRpm(LauncherLane.RIGHT, targetRpm);

        // Spin up
        launcher.setSpinMode(LauncherSubsystem.SpinMode.FULL);
        startTime = System.currentTimeMillis();

        // TODO: Log shot data for continued improvement
        // robot.shotLogger.logShotAttempt(...);
    }

    @Override
    public void update() {
        // Could dynamically adjust RPM if distance changes
        // (Advanced: track moving targets)
    }

    @Override
    public boolean isDone() {
        // Complete when launchers are at target
        if (areEnabledLaunchersReady()) {
            return true;
        }

        // Safety timeout
        double elapsedSeconds = (System.currentTimeMillis() - startTime) / 1000.0;
        return elapsedSeconds >= FormulaConfig.timeoutSeconds;
    }

    @Override
    public void stop(boolean interrupted) {
        if (interrupted) {
            launcher.setSpinMode(LauncherSubsystem.SpinMode.IDLE);
            launcher.clearOverrides();
        }
    }

    /**
     * Gets distance to goal using best available method
     */
    private double getDistanceToGoal() {
        // Method 1: AprilTag vision (most accurate if tag is visible)
        if (FormulaConfig.useVisionDistance && vision != null) {
            Optional<Double> visionDistance = getDistanceFromVision();
            if (visionDistance.isPresent()) {
                return visionDistance.get();
            }
        }

        // Method 2: Fallback to estimated/known distance
        return fallbackDistanceInches;

        // TODO Method 3: Calculate from robot pose to goal pose
        // Pose robotPose = drive.getFollower().getPose();
        // Pose goalPose = FieldConstants.getGoalPose(alliance);
        // return Math.hypot(goalPose.getX() - robotPose.getX(),
        //                   goalPose.getY() - robotPose.getY());
    }

    /**
     * Gets distance from AprilTag vision
     * TODO: Implement based on your VisionSubsystem API
     */
    private Optional<Double> getDistanceFromVision() {
        // Example implementation (adjust to your vision subsystem):
        // if (vision.hasTarget()) {
        //     double distance = vision.getDistanceToTarget();
        //     return Optional.of(distance);
        // }
        return Optional.empty();
    }

    /**
     * Calculates optimal RPM for given distance using fitted formula
     */
    private double calculateRpmForDistance(double distanceInches) {
        double rpm;

        if (FormulaConfig.useQuadratic) {
            // Quadratic formula: RPM = a*d² + b*d + c
            rpm = FormulaConfig.quadraticA * distanceInches * distanceInches
                + FormulaConfig.quadraticB * distanceInches
                + FormulaConfig.quadraticC;
        } else {
            // Linear formula: RPM = slope * d + intercept
            rpm = FormulaConfig.rpmSlope * distanceInches
                + FormulaConfig.rpmIntercept;
        }

        // Apply safety limits
        return Range.clip(rpm, FormulaConfig.minRpm, FormulaConfig.maxRpm);
    }

    /**
     * Checks if enabled launchers are ready
     */
    private boolean areEnabledLaunchersReady() {
        for (LauncherLane lane : LauncherLane.values()) {
            double launchRpm = launcher.getLaunchRpm(lane);

            if (launchRpm <= 0.0) {
                continue; // Skip disabled
            }

            if (!launcher.isLaneReady(lane)) {
                return false;
            }
        }
        return true;
    }

    public double getTargetRpm() {
        return targetRpm;
    }
}

/*
 * USAGE EXAMPLES:
 *
 * // In LauncherCommands.java, add:
 * public LaunchAtDistanceCommand launchAtDistance(double distanceInches) {
 *     return new LaunchAtDistanceCommand(launcher, distanceInches);
 * }
 *
 * public LaunchAtDistanceCommand launchWithVision(VisionSubsystem vision) {
 *     return new LaunchAtDistanceCommand(launcher, vision);
 * }
 *
 * // In autonomous:
 * private Command spinUpLauncher() {
 *     // Option 1: Use vision
 *     return launcherCommands.launchWithVision(robot.vision);
 *
 *     // Option 2: Use known distance
 *     return launcherCommands.launchAtDistance(96.0); // 96 inches
 * }
 *
 * // DATA FITTING PROCESS:
 * 1. Collect shot data from Practice 1-2 (see ShotDataLogger)
 * 2. Export CSV, plot Distance vs RPM in Excel
 * 3. Add trendline (linear or polynomial)
 * 4. Excel shows equation: y = 25x + 1500
 *    - rpmSlope = 25
 *    - rpmIntercept = 1500
 * 5. Update FormulaConfig values
 * 6. Test at known distances to validate
 */
